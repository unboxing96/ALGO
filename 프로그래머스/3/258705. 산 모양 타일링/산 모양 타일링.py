# 풀이: 구글링
# 예시에서 주어진 타일을 좌상단부터 좌 -> 우 / 상 -> 하 순서대로 1, 2, 3, 4라고 명명하겠다.
# 4번 타일은 top이 있는 경우에만 가능하다. 케이스를 나눠야 한다.
# 3번 타일은 다음 사다리꼴과 이어지는 부분이다. 케이스를 나눠야 한다.
# 3번 타일을 기준으로 나눠보자

# 0단계를 생각해보자 (사다리꼴의 밑변이 2인 경우)
    # 3번으로 끝나는 경우
        # dp1[0], top[0] = 1가지
        # dp1[0], top[1] = 1가지
    # 1, 2, 4번으로 끝나는 경우
        # dp2[0], top[0] = 2가지
        # dp2[0], top[1] = 3가지

# 1단계를 생각해보자 (사다리꼴의 밑변이 3인 경우)
    # 1) 3번 시작, 3번 종료
        # dp1[0], dp1[1], top[0] = 1
        # dp1[0], dp1[1], top[1] = 1
    # 2) 3번 시작, [1, 2, 4]번 종료
        # dp1[0], dp2[1], top[0] = 1
        # dp1[0], dp2[1], top[1] = 2
    # 3) [1, 2, 4]번 시작, 3번 종료
        # dp2[0], dp1[1], top[0] = 1
        # dp2[0], dp1[1], top[1] = 1
    # 4) [1, 2, 4]번 시작, [1, 2, 4]번 종료
        # dp2[0], dp2[1], top[0] = 2
        # dp2[0], dp2[1], top[1] = 3

# 점화식을 도출해보자
    # dp1[1] = case 1 + case 3 = dp1[0] * 1 + dp2[0] * 1
    # dp2[1] = case 2 + case 4 = dp1[0] * (1 or 2) + dp2[0] * (2 or 3)
    
    # dp1[i] = dp1[i-1] + dp2[i-1]
    # dp2[i] = dp1[i-1] * (1 or 2) + dp2[i-1] * (2 or 3)
    

def solution(n, tops):
    MOD = 10007
    dp1 = [0] * n
    dp2 = [0] * n
    dp1[0] = 1
    dp2[0] = 2 + tops[0]
    
    for i in range(1, n):
        dp1[i] = (dp1[i - 1] + dp2[i - 1]) % MOD
        dp2[i] = (dp1[i - 1] * (1 + tops[i]) + dp2[i - 1] * (2 + tops[i])) % MOD
    
    return (dp1[-1] + dp2[-1]) % MOD









